# -*- coding: utf-8 -*-
"""Untitled47.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PRDBrvASMREc5zMkNiOzQBfqIdf-LseK
"""

import json
import os
from dataclasses import dataclass
from typing import Dict, List, Tuple, Optional

import numpy as np
import pandas as pd
from joblib import dump, load
from sklearn.linear_model import LinearRegression

from config import settings

COUNTRY_COL = "country"
DATE_COL = "date"
TARGET_COL = "revenue"

def _ensure_artifact_dir() -> None:
    os.makedirs(settings.ARTIFACT_DIR, exist_ok=True)

def featurize(country: str, target_date: pd.Timestamp) -> Dict[str, float]:
    # minimal inputs: country + date
    month = int(target_date.month)
    year = int(target_date.year)
    # cyclic month
    sin_m = float(np.sin(2 * np.pi * month / 12.0))
    cos_m = float(np.cos(2 * np.pi * month / 12.0))
    return {
        "month": float(month),
        "year": float(year),
        "sin_month": sin_m,
        "cos_month": cos_m,
        # country handled via one-hot at training/predict time
    }

def validate_inputs(payload: dict) -> Tuple[str, pd.Timestamp]:
    if not isinstance(payload, dict):
        raise ValueError("Payload must be JSON object.")

    if "date" not in payload:
        raise ValueError("Missing required field: date")
    if "country" not in payload:
        raise ValueError("Missing required field: country")

    country = str(payload["country"]).strip()
    if country == "":
        raise ValueError("country cannot be empty")

    try:
        target_date = pd.to_datetime(payload["date"])
    except Exception as e:
        raise ValueError(f"Invalid date format: {payload['date']}") from e

    # Standardize special aggregate country
    if country.upper() in {"ALL", "GLOBAL", "WORLD"}:
        country = "ALL"

    return country, target_date

@dataclass
class RevenueModel:
    model: LinearRegression
    countries: List[str]

    def _one_hot(self, country: str) -> List[float]:
        # "ALL" gets zeros (acts like global intercept)
        if country == "ALL":
            return [0.0] * len(self.countries)
        return [1.0 if c == country else 0.0 for c in self.countries]

    def predict_one(self, country: str, target_date: pd.Timestamp) -> float:
        base = featurize(country, target_date)
        x_num = [base["month"], base["year"], base["sin_month"], base["cos_month"]]
        x = np.array([x_num + self._one_hot(country)], dtype=float)
        y = self.model.predict(x)[0]
        return float(max(y, 0.0))

def save_train_stats(stats: dict) -> None:
    _ensure_artifact_dir()
    path = os.path.join(settings.ARTIFACT_DIR, settings.TRAIN_STATS_FILE)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(stats, f, ensure_ascii=False, indent=2)

def load_train_stats() -> Optional[dict]:
    path = os.path.join(settings.ARTIFACT_DIR, settings.TRAIN_STATS_FILE)
    if not os.path.exists(path):
        return None
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def save_model(revenue_model: RevenueModel) -> None:
    _ensure_artifact_dir()
    path = os.path.join(settings.ARTIFACT_DIR, settings.MODEL_FILE)
    dump({"model": revenue_model.model, "countries": revenue_model.countries}, path)

def load_model() -> RevenueModel:
    path = os.path.join(settings.ARTIFACT_DIR, settings.MODEL_FILE)
    if not os.path.exists(path):
        raise FileNotFoundError(
            f"Model artifact not found at {path}. Run: python train.py"
        )
    obj = load(path)
    return RevenueModel(model=obj["model"], countries=obj["countries"])

def train(df: pd.DataFrame) -> RevenueModel:
    df = df.copy()
    df[DATE_COL] = pd.to_datetime(df[DATE_COL])
    df[COUNTRY_COL] = df[COUNTRY_COL].astype(str)

    # Countries seen during training (excluding ALL)
    countries = sorted([c for c in df[COUNTRY_COL].unique().tolist() if c != "ALL"])

    # Build design matrix
    feats = []
    ys = []
    for _, row in df.iterrows():
        f = featurize(row[COUNTRY_COL], row[DATE_COL])
        x_num = [f["month"], f["year"], f["sin_month"], f["cos_month"]]
        one_hot = [1.0 if c == row[COUNTRY_COL] else 0.0 for c in countries]
        feats.append(x_num + one_hot)
        ys.append(float(row[TARGET_COL]))

    X = np.array(feats, dtype=float)
    y = np.array(ys, dtype=float)

    model = LinearRegression()
    model.fit(X, y)

    # Save simple training feature stats for drift monitoring
    stats = {
        "month_mean": float(df[DATE_COL].dt.month.mean()),
        "month_std": float(df[DATE_COL].dt.month.std(ddof=0) or 1.0),
        "year_mean": float(df[DATE_COL].dt.year.mean()),
        "year_std": float(df[DATE_COL].dt.year.std(ddof=0) or 1.0),
        "countries": countries,
    }
    save_train_stats(stats)

    return RevenueModel(model=model, countries=countries)